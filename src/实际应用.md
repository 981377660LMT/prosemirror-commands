好的，我们来深入、系统地讲解 prosemirror-commands 这个包中的所有命令，并探讨它们在实际业务中的应用。

prosemirror-commands 是 ProseMirror 生态中最基础、最重要的包之一。它提供了一系列与 Schema 无关的、通用的编辑“动作”或“意图”。你可以把它们看作是构建任何编辑器都需要的“标准操作指令集”。

### 核心设计思想：原子化、可组合、与 Schema 无关

1.  **原子化**: 每个命令都只做一件高度内聚的事情，比如 `deleteSelection` 只负责删除选区，`splitBlock` 只负责分割块级节点。
2.  **可组合**: 提供了 `chainCommands` 函数，可以将多个命令串联起来，形成一个“尝试列表”。这在绑定键盘快捷键时非常有用，例如，按 `Backspace` 键会依次尝试 `deleteSelection`、`joinBackward`、`selectNodeBackward`，直到有一个命令成功执行。
3.  **与 Schema 无关**: 这些命令不依赖于具体的节点类型（如 `paragraph` 或 `heading`），而是依赖于节点的通用属性（如 `isBlock`, `isTextblock`, `code`）。这使得它们可以在任何遵循 ProseMirror 规范的 Schema 中开箱即用。

---

### 命令分类与详解

我们将这些命令按功能分为几大类：

#### 第一类：基础选择与删除 (Selection & Deletion)

这是最基本的一组命令。

- **`deleteSelection`**:

  - **含义**: 如果当前选区不是空的（即用户选择了一段文本或一个节点），则删除选区内容。
  - **应用**: 几乎是所有删除类快捷键（`Backspace`, `Delete`）的第一道防线。用户选中文字后按删除，就是这个命令在起作用。

- **`selectNodeBackward` / `selectNodeForward`**:

  - **含义**: 当光标在文本块的开头/结尾时，尝试选中光标前/后的那个节点（如果该节点是可被 `NodeSelection` 选中的，如图片、视频）。
  - **应用**: 作为 `joinBackward`/`joinForward` 的后备方案。想象光标在一个段落开头，前面是一张图片。此时按 `Backspace`，`joinBackward` 无法合并段落和图片，于是 `selectNodeBackward` 生效，选中了那张图片，用户可以继续按 `Backspace` 删除它。这提供了非常流畅的“向后删除”体验。

- **`selectParentNode`**:

  - **含义**: 扩大选区，选中当前选区所在的最内层的父节点。
  - **应用**: 实现类似 VS Code 中 `Ctrl+Shift+RightArrow` 的“扩展选区”功能，或者在面包屑导航中点击父节点以选中它。

- **`selectAll`**:

  - **含义**: 选中整个文档。
  - **应用**: 绑定到 `Cmd/Ctrl+A`。

- **`selectTextblockStart` / `selectTextblockEnd`**:
  - **含义**: 将光标移动到当前文本块的开头或结尾。
  - **应用**: 在 Mac 上，`Ctrl+A` 和 `Ctrl+E` 默认绑定到这两个命令，用于行首/行尾跳转。

#### 第二类：块级节点操作 (Block Manipulation)

这是处理文档结构的核心，主要围绕着块级节点的合并、分割和提升。

- **`joinBackward` / `joinForward`**:

  - **含义**: 当光标在文本块的开头/结尾时，尝试将当前块与前/后一个块进行“连接”。这个“连接”是一个非常复杂和智能的算法 (`deleteBarrier`)：
    1.  **直接合并**: 如果两个块是兼容的（如两个段落），直接将它们合并成一个。
    2.  **提升内容**: 如果一个块在另一个块内部（如 `<li>` 内的 `<p>`），尝试将内部块的内容“提升”到外部。
    3.  **包裹内容**: 如果一个块的内容可以被另一个块“包裹”（如将一个段落移动到 `<blockquote>` 中），则执行包裹操作。
    4.  **删除空节点**: 如果当前块是空的，尝试删除它。
    5.  **删除原子节点**: 如果旁边是原子节点（如分割线 `hr`），删除它。
  - **应用**: 这是 `Backspace` 和 `Delete` 键在光标状态下的核心逻辑，负责处理所有与块边界相关的删除和合并行为。

- **`joinUp` / `joinDown`**:

  - **含义**: 不管光标在哪，强制将当前选中的块或选区所在的块与上/下一个兄弟节点合并。
  - **应用**: 用于创建自定义的快捷键，例如 `Opt+UpArrow` 可以实现“向上合并段落”。

- **`lift`**:

  - **含义**: 将当前选区所在的块从其父容器中“提升”出来。例如，将一个列表项 `<li>` 提升为它外面的一个普通段落，或者将一个 `<blockquote>` 中的段落提升出来。
  - **应用**: 在实现快捷键（如 `Shift+Tab` 用于减少缩进）或工具栏按钮（“减少缩进”）时非常有用。

- **`splitBlock`**:

  - **含义**: 在当前光标位置分割块级节点。如果选区不为空，则先删除选区内容再分割。
  - **应用**: `Enter` 键的核心行为。在段落中间按回车，段落一分为二，就是这个命令的作用。

- **`splitBlockKeepMarks`**:

  - **含义**: 与 `splitBlock` 类似，但在分割后，新行会保持分割前的 marks（如粗体、斜体）。
  - **应用**: 在需要保持样式连续性的场景下（如在加粗的文本中间按回车），使用它代替 `splitBlock` 可以提供更好的用户体验。通常绑定到 `Shift+Enter` 来创建软换行（`<br>`），但也可用于普通回车。

- **`liftEmptyBlock`**:

  - **含义**: 如果光标在一个空的文本块中，尝试 `lift` 这个块。
  - **应用**: 作为 `Enter` 键的备选行为之一。例如，在一个空的列表项中按回车，不是创建一个新的空列表项，而是“跳出”列表，创建一个普通段落。

- **`createParagraphNear`**:
  - **含义**: 当一个非文本块节点（如图片、视频）被选中时，在它的前面或后面创建一个新的空段落。
  - **应用**: 同样是 `Enter` 键的备选行为。当用户选中一张图片后按回车，可以在图片下方创建一个新段落供用户输入，而不是在图片内部做分割。

#### 第三类：特定节点类型的命令 (Node-Specific Commands)

这些命令针对具有特定 `spec` 属性的节点。

- **`newlineInCode`**:

  - **含义**: 如果选区在 `code: true` 的节点（通常是 `code_block`）内，插入一个换行符 `\n`，而不是执行 `splitBlock`。
  - **应用**: 这是 `Enter` 键在代码块中的标准行为，确保在代码块中按回车是换行，而不是将代码块一分为二。

- **`exitCode`**:
  - **含义**: 如果光标在 `code: true` 的节点的末尾，在代码块之后创建一个新的默认块（通常是段落），并将光标移入其中。
  - **应用**: 实现“跳出代码块”的功能，通常绑定到 `Cmd/Ctrl+Enter` 或连续按三次 `Enter`。

#### 第四类：参数化命令 (Parameterized Commands)

这些是高阶函数，它们接收参数并返回一个具体的命令函数。这是创建自定义工具栏的核心。

- **`wrapIn(nodeType, attrs)`**:

  - **含义**: 返回一个命令，该命令会将当前选区用给定的 `nodeType` 包裹起来。例如，用 `blockquote` 包裹选中的段落。
  - **应用**: 实现“引用”、“警告框”等块级容器的工具栏按钮。

- **`setBlockType(nodeType, attrs)`**:

  - **含义**: 返回一个命令，该命令会将当前选中的文本块的类型更改为给定的 `nodeType`。例如，将一个段落 `paragraph` 变为一级标题 `heading`。
  - **应用**: 实现标题选择（H1, H2, H3...）、段落/代码块切换等工具栏下拉菜单或按钮。

- **`toggleMark(markType, attrs)`**:

  - **含义**: 返回一个命令，该命令会切换（添加或移除）选区中的 `mark`。
  - **应用**: 实现所有行内样式的工具栏按钮，如**加粗** (`bold`)、_斜体_ (`italic`)、<u>下划线</u> (`underline`)、链接 (`link`) 等。这是最常用的参数化命令。

- **`autoJoin(command, isJoinable)`**:
  - **含义**: 一个命令包装器。它会先执行传入的 `command`，然后检查该 `command` 产生的变更是否导致了两个可“连接”的节点相邻。如果是，它会自动将它们合并。
  - **应用**: 提升编辑体验。例如，当用户删除两个列表之间的段落时，`autoJoin` 可以自动将两个列表合并成一个，而不是让它们保持分离。

#### 第五类：组合与 Keymap

- **`chainCommands(...commands)`**:

  - **含义**: 将多个命令链接成一个调用链。它会按顺序执行每个命令，一旦有一个返回 `true`，链条就停止并返回 `true`。如果所有命令都返回 `false`，它才返回 `false`。
  - **应用**: 这是构建 `keymap` 的基石。几乎所有的键盘快捷键都绑定到一个 `chainCommands` 上，以处理各种上下文情况。例如，`baseKeymap` 中 `Enter` 键就绑定了 `chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock)`。

- **`baseKeymap`, `pcBaseKeymap`, `macBaseKeymap`**:
  - **含义**: 提供了一套跨平台的、非常合理的默认键盘快捷键绑定。
  - **应用**: 在创建编辑器实例时，通常会将 `baseKeymap` 作为 `keymap` 插件的基础，然后再叠加自己业务相关的快捷键。这能让你在几分钟内就拥有一个行为基本正常的编辑器。

### 总结

prosemirror-commands 为开发者提供了一个强大、灵活且经过深思熟虑的工具集。通过理解并组合这些基础命令，你可以：

1.  **快速搭建功能完备的编辑器**: `baseKeymap` 提供了开箱即用的核心编辑体验。
2.  **创建丰富的自定义工具栏**: 使用 `wrapIn`, `setBlockType`, `toggleMark` 可以轻松实现各种格式化按钮。
3.  **定义复杂的键盘行为**: `chainCommands` 让你能够为同一个快捷键在不同上下文下定义不同的行为，从而创造出流畅、智能的编辑体验。

掌握这个包是精通 ProseMirror 的关键一步，它连接了底层的 `Transaction` 模型和上层的用户交互，是实现编辑器“功能”的核心所在。
